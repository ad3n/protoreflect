package protowrap

import (
	"github.com/jhump/protoreflect/v2/internal/wrappers"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

// ProtoFromDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromDescriptor(d protoreflect.Descriptor) proto.Message {
	switch d := d.(type) {
	case protoreflect.FileDescriptor:
		return ProtoFromFileDescriptor(d)
	case protoreflect.MessageDescriptor:
		return ProtoFromMessageDescriptor(d)
	case protoreflect.FieldDescriptor:
		return ProtoFromFieldDescriptor(d)
	case protoreflect.OneofDescriptor:
		return ProtoFromOneofDescriptor(d)
	case protoreflect.EnumDescriptor:
		return ProtoFromEnumDescriptor(d)
	case protoreflect.EnumValueDescriptor:
		return ProtoFromEnumValueDescriptor(d)
	case protoreflect.ServiceDescriptor:
		return ProtoFromServiceDescriptor(d)
	case protoreflect.MethodDescriptor:
		return ProtoFromMethodDescriptor(d)
	default:
		// WTF??
		if res, ok := d.(ProtoWrapper); ok {
			return res.AsProto()
		}
		return nil
	}
}

// ProtoFromFileDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For file descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromFileDescriptor(d protoreflect.FileDescriptor) *descriptorpb.FileDescriptorProto {
	if imp, ok := d.(protoreflect.FileImport); ok {
		d = imp.FileDescriptor
	}
	if res, ok := d.(FileWrapper); ok {
		return res.FileDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if fd, ok := res.AsProto().(*descriptorpb.FileDescriptorProto); ok {
			return fd
		}
	}
	return protodesc.ToFileDescriptorProto(d)
}

// ProtoFromMessageDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For message descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Message descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromMessageDescriptor(d protoreflect.MessageDescriptor) *descriptorpb.DescriptorProto {
	if res, ok := d.(MessageWrapper); ok {
		return res.MessageDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if md, ok := res.AsProto().(*descriptorpb.DescriptorProto); ok {
			return md
		}
	}
	return protodesc.ToDescriptorProto(d)
}

// ProtoFromFieldDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For field descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Field descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromFieldDescriptor(d protoreflect.FieldDescriptor) *descriptorpb.FieldDescriptorProto {
	if res, ok := d.(FieldWrapper); ok {
		return res.FieldDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if fd, ok := res.AsProto().(*descriptorpb.FieldDescriptorProto); ok {
			return fd
		}
	}
	return protodesc.ToFieldDescriptorProto(d)
}

// ProtoFromOneofDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For oneof descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Oneof descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromOneofDescriptor(d protoreflect.OneofDescriptor) *descriptorpb.OneofDescriptorProto {
	if res, ok := d.(OneofWrapper); ok {
		return res.OneofDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if ood, ok := res.AsProto().(*descriptorpb.OneofDescriptorProto); ok {
			return ood
		}
	}
	return protodesc.ToOneofDescriptorProto(d)
}

// ProtoFromEnumDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For enum descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Enum descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromEnumDescriptor(d protoreflect.EnumDescriptor) *descriptorpb.EnumDescriptorProto {
	if res, ok := d.(EnumWrapper); ok {
		return res.EnumDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if ed, ok := res.AsProto().(*descriptorpb.EnumDescriptorProto); ok {
			return ed
		}
	}
	return protodesc.ToEnumDescriptorProto(d)
}

// ProtoFromEnumValueDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For enum value descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Enum value descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromEnumValueDescriptor(d protoreflect.EnumValueDescriptor) *descriptorpb.EnumValueDescriptorProto {
	if res, ok := d.(EnumValueWrapper); ok {
		return res.EnumValueDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if ed, ok := res.AsProto().(*descriptorpb.EnumValueDescriptorProto); ok {
			return ed
		}
	}
	return protodesc.ToEnumValueDescriptorProto(d)
}

// ProtoFromServiceDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For service descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Service descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromServiceDescriptor(d protoreflect.ServiceDescriptor) *descriptorpb.ServiceDescriptorProto {
	if res, ok := d.(ServiceWrapper); ok {
		return res.ServiceDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if sd, ok := res.AsProto().(*descriptorpb.ServiceDescriptorProto); ok {
			return sd
		}
	}
	return protodesc.ToServiceDescriptorProto(d)
}

// ProtoFromMethodDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For method descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Method descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromMethodDescriptor(d protoreflect.MethodDescriptor) *descriptorpb.MethodDescriptorProto {
	if res, ok := d.(MethodWrapper); ok {
		return res.MethodDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if md, ok := res.AsProto().(*descriptorpb.MethodDescriptorProto); ok {
			return md
		}
	}
	return protodesc.ToMethodDescriptorProto(d)
}

// WrappedDescriptor represents a descriptor that has been wrapped or decorated.
// Its sole method allows recovery of the underlying, original descriptor.
type WrappedDescriptor interface {
	Unwrap() protoreflect.Descriptor
}

var _ WrappedDescriptor = wrappers.WrappedDescriptor(nil)
var _ wrappers.WrappedDescriptor = WrappedDescriptor(nil)
var _ WrappedDescriptor = (*wrappers.File)(nil)
var _ WrappedDescriptor = (*wrappers.Message)(nil)
var _ WrappedDescriptor = (*wrappers.Field)(nil)
var _ WrappedDescriptor = (*wrappers.Oneof)(nil)
var _ WrappedDescriptor = (*wrappers.Extension)(nil)
var _ WrappedDescriptor = (*wrappers.Enum)(nil)
var _ WrappedDescriptor = (*wrappers.EnumValue)(nil)
var _ WrappedDescriptor = (*wrappers.Service)(nil)
var _ WrappedDescriptor = (*wrappers.Method)(nil)

// Unwrap unwraps the given descriptor. If it implements WrappedDescriptor,
// the underlying descriptor is returned. Otherwise, d is returned as is.
func Unwrap(d protoreflect.Descriptor) protoreflect.Descriptor {
	return wrappers.Unwrap(d)
}

// UnwrapFile unwraps the given file descriptor. If it implements
// WrappedDescriptor, the underlying descriptor is returned. Otherwise,
// fd is returned as is.
func UnwrapFile(fd protoreflect.FileDescriptor) protoreflect.FileDescriptor {
	w, ok := fd.(WrappedDescriptor)
	if !ok {
		// not wrapped
		return fd
	}
	wrapped := w.Unwrap()
	if wrapped == nil {
		return fd
	}
	return wrapped.(protoreflect.FileDescriptor)
}

// UnwrapMessage unwraps the given message descriptor. If it implements
// WrappedDescriptor, the underlying descriptor is returned. Otherwise,
// md is returned as is.
func UnwrapMessage(md protoreflect.MessageDescriptor) protoreflect.MessageDescriptor {
	w, ok := md.(WrappedDescriptor)
	if !ok {
		// not wrapped
		return md
	}
	wrapped := w.Unwrap()
	if wrapped == nil {
		return md
	}
	return wrapped.(protoreflect.MessageDescriptor)
}

// UnwrapField unwraps the given field descriptor. If it implements
// WrappedDescriptor, the underlying descriptor is returned. Otherwise,
// fld is returned as is.
func UnwrapField(fld protoreflect.FieldDescriptor) protoreflect.FieldDescriptor {
	w, ok := fld.(WrappedDescriptor)
	if !ok {
		// not wrapped
		return fld
	}
	wrapped := w.Unwrap()
	if wrapped == nil {
		return fld
	}
	return wrapped.(protoreflect.FieldDescriptor)
}

// UnwrapOneof unwraps the given oneof descriptor. If it implements
// WrappedDescriptor, the underlying descriptor is returned. Otherwise,
// ood is returned as is.
func UnwrapOneof(ood protoreflect.OneofDescriptor) protoreflect.OneofDescriptor {
	w, ok := ood.(WrappedDescriptor)
	if !ok {
		// not wrapped
		return ood
	}
	wrapped := w.Unwrap()
	if wrapped == nil {
		return ood
	}
	return wrapped.(protoreflect.OneofDescriptor)
}

// UnwrapEnum unwraps the given enum descriptor. If it implements
// WrappedDescriptor, the underlying descriptor is returned. Otherwise,
// ed is returned as is.
func UnwrapEnum(ed protoreflect.EnumDescriptor) protoreflect.EnumDescriptor {
	w, ok := ed.(WrappedDescriptor)
	if !ok {
		// not wrapped
		return ed
	}
	wrapped := w.Unwrap()
	if wrapped == nil {
		return ed
	}
	return wrapped.(protoreflect.EnumDescriptor)
}

// UnwrapEnumValue unwraps the given enum value descriptor. If it implements
// WrappedDescriptor, the underlying descriptor is returned. Otherwise,
// evd is returned as is.
func UnwrapEnumValue(evd protoreflect.EnumValueDescriptor) protoreflect.EnumValueDescriptor {
	w, ok := evd.(WrappedDescriptor)
	if !ok {
		// not wrapped
		return evd
	}
	wrapped := w.Unwrap()
	if wrapped == nil {
		return evd
	}
	return wrapped.(protoreflect.EnumValueDescriptor)
}

// UnwrapService unwraps the given service descriptor. If it implements
// WrappedDescriptor, the underlying descriptor is returned. Otherwise,
// sd is returned as is.
func UnwrapService(sd protoreflect.ServiceDescriptor) protoreflect.ServiceDescriptor {
	w, ok := sd.(WrappedDescriptor)
	if !ok {
		// not wrapped
		return sd
	}
	wrapped := w.Unwrap()
	if wrapped == nil {
		return sd
	}
	return wrapped.(protoreflect.ServiceDescriptor)
}

// UnwrapMethod unwraps the given method descriptor. If it implements
// WrappedDescriptor, the underlying descriptor is returned. Otherwise,
// mtd is returned as is.
func UnwrapMethod(mtd protoreflect.MethodDescriptors) protoreflect.MethodDescriptors {
	w, ok := mtd.(WrappedDescriptor)
	if !ok {
		// not wrapped
		return mtd
	}
	wrapped := w.Unwrap()
	if wrapped == nil {
		return mtd
	}
	return wrapped.(protoreflect.MethodDescriptors)
}
