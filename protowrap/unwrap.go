package protowrap

import (
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/jhump/protoreflect/v2/internal/wrappers"
)

// ProtoFromDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For descriptors generated by the compiler, this is an
// inexpensive and non-lossy operation. Descriptors from other sources
// however may be expensive (to re-create a proto) and even lossy.
func ProtoFromDescriptor(d protoreflect.Descriptor) proto.Message {
	switch d := d.(type) {
	case protoreflect.FileDescriptor:
		return ProtoFromFileDescriptor(d)
	case protoreflect.MessageDescriptor:
		return ProtoFromMessageDescriptor(d)
	case protoreflect.FieldDescriptor:
		return ProtoFromFieldDescriptor(d)
	case protoreflect.OneofDescriptor:
		return ProtoFromOneofDescriptor(d)
	case protoreflect.EnumDescriptor:
		return ProtoFromEnumDescriptor(d)
	case protoreflect.EnumValueDescriptor:
		return ProtoFromEnumValueDescriptor(d)
	case protoreflect.ServiceDescriptor:
		return ProtoFromServiceDescriptor(d)
	case protoreflect.MethodDescriptor:
		return ProtoFromMethodDescriptor(d)
	default:
		// WTF??
		if res, ok := d.(ProtoWrapper); ok {
			return res.AsProto()
		}
		return nil
	}
}

// ProtoFromFileDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For file descriptors created with FromFileDescriptorProto, this
// is an inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create the proto) and possibly even lossy.
func ProtoFromFileDescriptor(d protoreflect.FileDescriptor) *descriptorpb.FileDescriptorProto {
	return wrappers.ProtoFromFileDescriptor(d)
}

// ProtoFromMessageDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For message descriptors created with FromFileDescriptorProto, this
// is an inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create the proto) and possibly even lossy.
func ProtoFromMessageDescriptor(d protoreflect.MessageDescriptor) *descriptorpb.DescriptorProto {
	if res, ok := d.(MessageWrapper); ok {
		return res.MessageDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if md, ok := res.AsProto().(*descriptorpb.DescriptorProto); ok {
			return md
		}
	}
	return protodesc.ToDescriptorProto(d)
}

// ProtoFromFieldDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For field descriptors created with FromFileDescriptorProto, this
// is an inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create the proto) and possibly even lossy.
func ProtoFromFieldDescriptor(d protoreflect.FieldDescriptor) *descriptorpb.FieldDescriptorProto {
	if res, ok := d.(FieldWrapper); ok {
		return res.FieldDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if fd, ok := res.AsProto().(*descriptorpb.FieldDescriptorProto); ok {
			return fd
		}
	}
	return protodesc.ToFieldDescriptorProto(d)
}

// ProtoFromOneofDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For oneof descriptors created with FromFileDescriptorProto, this
// is an inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create the proto) and possibly even lossy.
func ProtoFromOneofDescriptor(d protoreflect.OneofDescriptor) *descriptorpb.OneofDescriptorProto {
	if res, ok := d.(OneofWrapper); ok {
		return res.OneofDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if ood, ok := res.AsProto().(*descriptorpb.OneofDescriptorProto); ok {
			return ood
		}
	}
	return protodesc.ToOneofDescriptorProto(d)
}

// ProtoFromEnumDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For enum descriptors created with FromFileDescriptorProto, this
// is an inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create the proto) and possibly even lossy.
func ProtoFromEnumDescriptor(d protoreflect.EnumDescriptor) *descriptorpb.EnumDescriptorProto {
	if res, ok := d.(EnumWrapper); ok {
		return res.EnumDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if ed, ok := res.AsProto().(*descriptorpb.EnumDescriptorProto); ok {
			return ed
		}
	}
	return protodesc.ToEnumDescriptorProto(d)
}

// ProtoFromEnumValueDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For enum value descriptors created with FromFileDescriptorProto, this
// is an inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create the proto) and possibly even lossy.
func ProtoFromEnumValueDescriptor(d protoreflect.EnumValueDescriptor) *descriptorpb.EnumValueDescriptorProto {
	if res, ok := d.(EnumValueWrapper); ok {
		return res.EnumValueDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if ed, ok := res.AsProto().(*descriptorpb.EnumValueDescriptorProto); ok {
			return ed
		}
	}
	return protodesc.ToEnumValueDescriptorProto(d)
}

// ProtoFromServiceDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For service descriptors created with FromFileDescriptorProto, this
// is an inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create the proto) and possibly even lossy.
func ProtoFromServiceDescriptor(d protoreflect.ServiceDescriptor) *descriptorpb.ServiceDescriptorProto {
	if res, ok := d.(ServiceWrapper); ok {
		return res.ServiceDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if sd, ok := res.AsProto().(*descriptorpb.ServiceDescriptorProto); ok {
			return sd
		}
	}
	return protodesc.ToServiceDescriptorProto(d)
}

// ProtoFromMethodDescriptor extracts a descriptor proto from the given "rich"
// descriptor. For method descriptors created with FromFileDescriptorProto, this
// is an inexpensive and non-lossy operation. File descriptors from other sources
// however may be expensive (to re-create the proto) and possibly even lossy.
func ProtoFromMethodDescriptor(d protoreflect.MethodDescriptor) *descriptorpb.MethodDescriptorProto {
	if res, ok := d.(MethodWrapper); ok {
		return res.MethodDescriptorProto()
	}
	if res, ok := d.(ProtoWrapper); ok {
		if md, ok := res.AsProto().(*descriptorpb.MethodDescriptorProto); ok {
			return md
		}
	}
	return protodesc.ToMethodDescriptorProto(d)
}

// WrappedDescriptor represents a descriptor that has been wrapped or decorated.
// Its sole method allows recovery of the underlying, original descriptor.
type WrappedDescriptor interface {
	Unwrap() protoreflect.Descriptor
}

var _ WrappedDescriptor = wrappers.WrappedDescriptor(nil)
var _ wrappers.WrappedDescriptor = WrappedDescriptor(nil)
var _ WrappedDescriptor = (*wrappers.File)(nil)
var _ WrappedDescriptor = (*wrappers.Message)(nil)
var _ WrappedDescriptor = (*wrappers.Field)(nil)
var _ WrappedDescriptor = (*wrappers.Oneof)(nil)
var _ WrappedDescriptor = (*wrappers.Extension)(nil)
var _ WrappedDescriptor = (*wrappers.Enum)(nil)
var _ WrappedDescriptor = (*wrappers.EnumValue)(nil)
var _ WrappedDescriptor = (*wrappers.Service)(nil)
var _ WrappedDescriptor = (*wrappers.Method)(nil)

// Unwrap unwraps the given descriptor. If it implements WrappedDescriptor,
// the underlying descriptor is returned. This also supports more strongly
// typed unwrap methods. For example, if the given value is a FileDescriptor
// and has a method with the following signature, it will be invoked:
//
//	Unwrap() protoreflect.FileDescriptor.
//
// Otherwise, if d cannot be unwrapped, it is returned as is. If it does have
// an Unwrap method, but that method returns nil, d is returned as is.
func Unwrap(d protoreflect.Descriptor) protoreflect.Descriptor {
	d, _ = wrappers.Unwrap(d)
	return d
}

// UnwrapFile unwraps the given file descriptor. See Unwrap.
func UnwrapFile(fd protoreflect.FileDescriptor) protoreflect.FileDescriptor {
	return unwrap(fd)
}

// UnwrapMessage unwraps the given message descriptor. See Unwrap.
func UnwrapMessage(md protoreflect.MessageDescriptor) protoreflect.MessageDescriptor {
	return unwrap(md)
}

// UnwrapField unwraps the given field descriptor. See Unwrap.
func UnwrapField(fld protoreflect.FieldDescriptor) protoreflect.FieldDescriptor {
	return unwrap(fld)
}

// UnwrapOneof unwraps the given oneof descriptor. See Unwrap.
func UnwrapOneof(ood protoreflect.OneofDescriptor) protoreflect.OneofDescriptor {
	return unwrap(ood)
}

// UnwrapEnum unwraps the given enum descriptor. See Unwrap
func UnwrapEnum(ed protoreflect.EnumDescriptor) protoreflect.EnumDescriptor {
	return unwrap(ed)
}

// UnwrapEnumValue unwraps the given enum value descriptor. See Unwrap.
func UnwrapEnumValue(evd protoreflect.EnumValueDescriptor) protoreflect.EnumValueDescriptor {
	return unwrap(evd)
}

// UnwrapService unwraps the given service descriptor. See Unwrap.
func UnwrapService(sd protoreflect.ServiceDescriptor) protoreflect.ServiceDescriptor {
	return unwrap(sd)
}

// UnwrapMethod unwraps the given method descriptor. See Unwrap.
func UnwrapMethod(mtd protoreflect.MethodDescriptor) protoreflect.MethodDescriptor {
	return unwrap(mtd)
}

func unwrap[D protoreflect.Descriptor](d D) D {
	return Unwrap(d).(D)
}

// Root unwraps the given descriptor entirely, returning the root underlying
// descriptor. It is like calling Unwrap(d) and then continually calling
// Unwrap again on each result until there is nothing more to unwrap.
func Root(d protoreflect.Descriptor) protoreflect.Descriptor {
	for {
		d, wasWrapped := wrappers.Unwrap(d)
		if !wasWrapped {
			return d
		}
	}
}

// RootFile entirely unwraps the given file descriptor, recovering the
// root underlying descriptor. See Root.
func RootFile(fd protoreflect.FileDescriptor) protoreflect.FileDescriptor {
	return root(fd)
}

// RootMessage entirely unwraps the given message descriptor, recovering the
// root underlying descriptor. See Root.
func RootMessage(md protoreflect.MessageDescriptor) protoreflect.MessageDescriptor {
	return root(md)
}

// RootField entirely unwraps the given field descriptor, recovering the
// root underlying descriptor. See Root.
func RootField(fld protoreflect.FieldDescriptor) protoreflect.FieldDescriptor {
	return root(fld)
}

// RootOneof entirely unwraps the given oneof descriptor, recovering the
// root underlying descriptor. See Root.
func RootOneof(ood protoreflect.OneofDescriptor) protoreflect.OneofDescriptor {
	return root(ood)
}

// RootEnum entirely unwraps the given enum descriptor, recovering the
// root underlying descriptor. See Root.
func RootEnum(ed protoreflect.EnumDescriptor) protoreflect.EnumDescriptor {
	return root(ed)
}

// RootEnumValue entirely unwraps the given enum value descriptor, recovering the
// root underlying descriptor. See Root.
func RootEnumValue(evd protoreflect.EnumValueDescriptor) protoreflect.EnumValueDescriptor {
	return root(evd)
}

// RootService entirely unwraps the given service descriptor, recovering the
// root underlying descriptor. See Root.
func RootService(sd protoreflect.ServiceDescriptor) protoreflect.ServiceDescriptor {
	return root(sd)
}

// RootMethod entirely unwraps the given method descriptor, recovering the
// root underlying descriptor. See Root.
func RootMethod(mtd protoreflect.MethodDescriptor) protoreflect.MethodDescriptor {
	return root(mtd)
}

func root[D protoreflect.Descriptor](d D) D {
	return Root(d).(D)
}
