package protoresolve

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
)

var (
	// GlobalDescriptors provides a view of protoregistry.GlobalFiles and protoregistry.GlobalTypes
	// as a Resolver.
	GlobalDescriptors = ResolverFromPools(protoregistry.GlobalFiles, protoregistry.GlobalTypes)

	// ErrNotFound is a sentinel error that is returned from resolvers to indicate that the named
	// element is not known to the registry. It is the same as protoregistry.NotFound.
	ErrNotFound = protoregistry.NotFound
)

// FileResolver can resolve file descriptors by path.
type FileResolver interface {
	FindFileByPath(string) (protoreflect.FileDescriptor, error)
}

// FilePool is a FileResolver that also allows iteration over the known file descriptors.
type FilePool interface {
	FileResolver
	NumFiles() int
	RangeFiles(fn func(protoreflect.FileDescriptor) bool)
	NumFilesByPackage(name protoreflect.FullName) int
	RangeFilesByPackage(name protoreflect.FullName, fn func(protoreflect.FileDescriptor) bool)
}

// DescriptorResolver can resolve descriptors by full name.
type DescriptorResolver interface {
	FindDescriptorByName(protoreflect.FullName) (protoreflect.Descriptor, error)
}

// DescriptorPool is a FilePool that also functions as a DescriptorResolver.
type DescriptorPool interface {
	FilePool
	DescriptorResolver
}

var _ DescriptorPool = (*Registry)(nil)
var _ DescriptorPool = (*protoregistry.Files)(nil)

// DescriptorRegistry is a file and descriptor resolver that allows the caller to add files
// (and their contained descriptors) to the set of files and descriptors it can resolve.
type DescriptorRegistry interface {
	DescriptorPool
	RegisterFile(protoreflect.FileDescriptor) error
}

var _ DescriptorRegistry = (*Registry)(nil)
var _ DescriptorRegistry = (*protoregistry.Files)(nil)

// TypedDescriptorResolver can resolve descriptors by full name and provides strongly-typed methods
// for each kind of descriptor.
//
// Note that FindFieldByName may return normal fields and may also return extension fields. But
// FindExtensionByName should only ever return extensions. If the fully-qualified name of a normal
// field is provided to FindExtensionByName, it should return an error indicating that the named
// element was the wrong kind.
type TypedDescriptorResolver interface {
	FindMessageByName(protoreflect.FullName) (protoreflect.MessageDescriptor, error)
	FindFieldByName(protoreflect.FullName) (protoreflect.FieldDescriptor, error)
	FindExtensionByName(protoreflect.FullName) (protoreflect.ExtensionDescriptor, error)
	FindOneofByName(protoreflect.FullName) (protoreflect.OneofDescriptor, error)
	FindEnumByName(protoreflect.FullName) (protoreflect.EnumDescriptor, error)
	FindEnumValueByName(protoreflect.FullName) (protoreflect.EnumValueDescriptor, error)
	FindServiceByName(protoreflect.FullName) (protoreflect.ServiceDescriptor, error)
	FindMethodByName(protoreflect.FullName) (protoreflect.MethodDescriptor, error)
}

// ExtensionResolver can resolve extensions based on the containing message name and field number.
type ExtensionResolver interface {
	FindExtensionByName(protoreflect.FullName) (protoreflect.ExtensionDescriptor, error)
	FindExtensionByNumber(message protoreflect.FullName, field protoreflect.FieldNumber) (protoreflect.ExtensionDescriptor, error)
}

// ExtensionPool is an ExtensionResolver that also allows iteration over all extensions for a message.
type ExtensionPool interface {
	ExtensionResolver
	RangeExtensionsByMessage(message protoreflect.FullName, fn func(protoreflect.ExtensionDescriptor) bool)
}

// MessageResolver can resolve messages based on their name or a type URL. URLs must include the
// fully-qualified type name as the last URI path component.
type MessageResolver interface {
	FindMessageByName(protoreflect.FullName) (protoreflect.MessageDescriptor, error)
	FindMessageByURL(url string) (protoreflect.MessageDescriptor, error)
}

// ExtensionTypeResolver can resolve extension types. An extension type includes more than just
// a descriptor but also refers to runtime types (which could be static types generated by the
// protoc-gen-go plugin).
//
// This interface is the same as protoregistry.ExtensionTypeResolver.
type ExtensionTypeResolver interface {
	FindExtensionByName(field protoreflect.FullName) (protoreflect.ExtensionType, error)
	FindExtensionByNumber(message protoreflect.FullName, field protoreflect.FieldNumber) (protoreflect.ExtensionType, error)
}

var _ protoregistry.ExtensionTypeResolver = ExtensionTypeResolver(nil)
var _ ExtensionTypeResolver = protoregistry.ExtensionTypeResolver(nil)

// MessageTypeResolver can resolve message types. A message type includes more than just a
// descriptor but also refers to runtime types (which could be static types generated by the
// protoc-gen-go plugin).
//
// This interface is the same as protoregistry.MessageTypeResolver.
type MessageTypeResolver interface {
	FindMessageByName(message protoreflect.FullName) (protoreflect.MessageType, error)
	FindMessageByURL(url string) (protoreflect.MessageType, error)
}

var _ protoregistry.MessageTypeResolver = MessageTypeResolver(nil)
var _ MessageTypeResolver = protoregistry.MessageTypeResolver(nil)

// EnumTypeResolver can resolve enum types. An enum type includes more than just a descriptor
// but also refers to runtime types (which could be static types generated by the
// protoc-gen-go plugin).
type EnumTypeResolver interface {
	FindEnumByName(enum protoreflect.FullName) (protoreflect.EnumType, error)
}

// SerializationResolver is a named interface that can be used as a resolver for
// various marshalling and unmarshalling operations. For example it can be used
// to recognize extensions when unmarshalling the binary format. And it can be used
// for recognizing extensions and the contents of Any messages when marshalling and
// unmarshalling the JSON and text formats.
//
// This type can be assigned to the following fields:
//   - proto.UnmarshalOptions.resolver
//   - protojson.MarshalOptions.resolver
//   - protojson.UnmarshalOptions.resolver
//   - prototext.MarshalOptions.resolver
//   - prototext.UnmarshalOptions.resolver
type SerializationResolver interface {
	ExtensionTypeResolver
	MessageTypeResolver
}

// TypeResolver can resolve all types: extensions, messages, and enums.
type TypeResolver interface {
	ExtensionTypeResolver
	MessageTypeResolver
	EnumTypeResolver
}

// DependencyResolver can resolve dependencies, which is needed when
// constructing a [protoreflect.FileDescriptor] from a FileDescriptorProto.
//
// This interface is the same as [protodesc.Resolver].
type DependencyResolver interface {
	FileResolver
	DescriptorResolver
}

var _ protodesc.Resolver = DependencyResolver(nil)
var _ DependencyResolver = protodesc.Resolver(nil)

// Resolver is a comprehensive resolver interface with methods for resolving all kinds
// of descriptors.
//
// The AsTypeResolver method returns a view of the resolver as a TypeResolver. In most
// cases, the returned types will be dynamic types constructed using the resolver's
// descriptors and the [google.golang.org/protobuf/types/dynamicpb] package.
type Resolver interface {
	DescriptorPool
	TypedDescriptorResolver
	ExtensionPool
	MessageResolver
	AsTypeResolver() TypeResolver
}

type DescriptorKind int

// The various supported TypeKind values.
const (
	DescriptorKindUnknown = DescriptorKind(iota)
	DescriptorKindFile
	DescriptorKindMessage
	DescriptorKindField
	DescriptorKindOneof
	DescriptorKindEnum
	DescriptorKindEnumValue
	DescriptorKindExtension
	DescriptorKindService
	DescriptorKindMethod
)

func KindOf(d protoreflect.Descriptor) DescriptorKind {
	switch d := d.(type) {
	case protoreflect.FileDescriptor:
		return DescriptorKindFile
	case protoreflect.MessageDescriptor:
		return DescriptorKindMessage
	case protoreflect.FieldDescriptor:
		if d.IsExtension() {
			return DescriptorKindExtension
		}
		return DescriptorKindField
	case protoreflect.OneofDescriptor:
		return DescriptorKindOneof
	case protoreflect.EnumDescriptor:
		return DescriptorKindEnum
	case protoreflect.EnumValueDescriptor:
		return DescriptorKindEnumValue
	case protoreflect.ServiceDescriptor:
		return DescriptorKindService
	case protoreflect.MethodDescriptor:
		return DescriptorKindMethod
	default:
		return DescriptorKindUnknown
	}
}

func (k DescriptorKind) String() string {
	switch k {
	case DescriptorKindFile:
		return "file"
	case DescriptorKindMessage:
		return "message"
	case DescriptorKindField:
		return "field"
	case DescriptorKindOneof:
		return "oneof"
	case DescriptorKindEnum:
		return "enum"
	case DescriptorKindEnumValue:
		return "enum value"
	case DescriptorKindExtension:
		return "extension"
	case DescriptorKindService:
		return "service"
	case DescriptorKindMethod:
		return "method"
	case DescriptorKindUnknown:
		return "unknown"
	default:
		return fmt.Sprintf("unknown kind (%d)", k)
	}
}

func (k DescriptorKind) withArticle() string {
	switch k {
	case DescriptorKindFile:
		return "a file"
	case DescriptorKindMessage:
		return "a message"
	case DescriptorKindField:
		return "a field"
	case DescriptorKindOneof:
		return "a oneof"
	case DescriptorKindEnum:
		return "an enum"
	case DescriptorKindEnumValue:
		return "an enum value"
	case DescriptorKindExtension:
		return "an extension"
	case DescriptorKindService:
		return "a service"
	case DescriptorKindMethod:
		return "a method"
	case DescriptorKindUnknown:
		return "unknown"
	default:
		return fmt.Sprintf("unknown kind (%d)", k)
	}
}

type ErrUnexpectedType struct {
	// Only one of URL or Name will be set, depending on whether
	// the type was looked up by URL or name.
	URL string
	// The kind of descriptor that was expected.
	Expecting DescriptorKind
	// The descriptor that was actually found.
	Descriptor protoreflect.Descriptor
}

func (e *ErrUnexpectedType) Error() string {
	return fmt.Sprintf("wrong kind of descriptor for URL %q: expected %s, got %s", e.URL, e.Expecting.withArticle(), descKindWithArticle(e.Descriptor))
}

// FindExtensionByNumber searches the given descriptor pool for the requested extension.
// This performs an inefficient search through all files and extensions in the pool.
// It returns nil if the extension is not found in the file.
func FindExtensionByNumber(res DescriptorPool, message protoreflect.FullName, field protoreflect.FieldNumber) protoreflect.ExtensionDescriptor {
	var ext protoreflect.ExtensionDescriptor
	res.RangeFiles(func(fd protoreflect.FileDescriptor) bool {
		ext = FindExtensionByNumberInFile(fd, message, field)
		return ext == nil
	})
	return ext
}

// FindExtensionByNumberInFile searches all extension in the given file for the requested
// extension. It returns nil if the extension is not found in the file.
func FindExtensionByNumberInFile(file protoreflect.FileDescriptor, message protoreflect.FullName, field protoreflect.FieldNumber) protoreflect.ExtensionDescriptor {
	return findExtension(file, message, field)
}

func findExtension(container TypeContainer, message protoreflect.FullName, field protoreflect.FieldNumber) protoreflect.FieldDescriptor {
	// search extensions in this scope
	exts := container.Extensions()
	for i, length := 0, exts.Len(); i < length; i++ {
		ext := exts.Get(i)
		if ext.Number() == field && ext.ContainingMessage().FullName() == message {
			return ext
		}
	}

	// if not found, search nested scopes
	msgs := container.Messages()
	for i, length := 0, msgs.Len(); i < length; i++ {
		msg := msgs.Get(i)
		ext := findExtension(msg, message, field)
		if ext != nil {
			return ext
		}
	}
	return nil
}

// RangeExtensionsByMessage enumerates all extensions in the given descriptor pool that
// extend the given message. It stops early if the given function returns false.
func RangeExtensionsByMessage(res DescriptorPool, message protoreflect.FullName, fn func(descriptor protoreflect.ExtensionDescriptor) bool) {
	var rangeInContext func(container TypeContainer, fn func(protoreflect.ExtensionDescriptor) bool) bool
	rangeInContext = func(container TypeContainer, fn func(protoreflect.ExtensionDescriptor) bool) bool {
		exts := container.Extensions()
		for i, length := 0, exts.Len(); i < length; i++ {
			ext := exts.Get(i)
			if ext.ContainingMessage().FullName() == message {
				if !fn(ext) {
					return false
				}
			}
		}
		msgs := container.Messages()
		for i, length := 0, msgs.Len(); i < length; i++ {
			msg := msgs.Get(i)
			if !rangeInContext(msg, fn) {
				return false
			}
		}
		return true
	}
	res.RangeFiles(func(file protoreflect.FileDescriptor) bool {
		return rangeInContext(file, fn)
	})
}

// FindDescriptorByNameInFile searches the given file for the element with the given
// fully-qualified name. This could be used to implement the
// [DescriptorResolver.FindDescriptorByName] method for a resolver that doesn't want
// to create an index of all descriptors. This returns nil if no element with the
// given name belongs to this file.
//
// This does not perform a brute-force search of all elements to find the given name.
// It breaks up the given name into components and then descends the descriptor
// hierarchy one element at a time. If the given name does not start with the file's
// package, it immediately returns nil.
func FindDescriptorByNameInFile(file protoreflect.FileDescriptor, sym protoreflect.FullName) protoreflect.Descriptor {
	symNoPkg := string(sym)
	if file.Package() != "" {
		symNoPkg = strings.TrimPrefix(string(sym), string(file.Package())+".")
		if symNoPkg == string(sym) {
			// symbol is not in this file's package
			return nil
		}
	}
	parts := strings.Split(symNoPkg, ".")
	return findSymbolInFile(parts, file)
}

func findSymbolInFile(symbolParts []string, fd protoreflect.FileDescriptor) protoreflect.Descriptor {
	// ==1 name means it's a direct child of this file
	if len(symbolParts) == 1 {
		n := protoreflect.Name(symbolParts[0])
		if d := fd.Messages().ByName(n); d != nil {
			return d
		}
		if d := fd.Enums().ByName(n); d != nil {
			return d
		}
		if d := fd.Extensions().ByName(n); d != nil {
			return d
		}
		if d := fd.Services().ByName(n); d != nil {
			return d
		}
		// enum values are defined in the scope that encloses the enum, so
		// we have to look in all enums to find top-level enum values
		enums := fd.Enums()
		for i, length := 0, enums.Len(); i < length; i++ {
			enum := enums.Get(i)
			if d := enum.Values().ByName(n); d != nil {
				return d
			}
		}
		// not in this file
		return nil
	}

	// >1 name means it's inside a message or (if ==2) a method inside a service
	first := protoreflect.Name(symbolParts[0])
	if len(symbolParts) == 2 {
		second := protoreflect.Name(symbolParts[1])
		if svc := fd.Services().ByName(first); svc != nil {
			if d := svc.Methods().ByName(second); d != nil {
				return d
			}
			return nil
		}
	}
	rest := symbolParts[1:]
	if msg := fd.Messages().ByName(first); msg != nil {
		return findSymbolInMessage(rest, msg)
	}

	// no other option; can't be in this file
	return nil
}

func findSymbolInMessage(symbolParts []string, md protoreflect.MessageDescriptor) protoreflect.Descriptor {
	// ==1 name means it's a direct child of this message
	if len(symbolParts) == 1 {
		n := protoreflect.Name(symbolParts[0])
		if d := md.Fields().ByName(n); d != nil {
			return d
		}
		if d := md.Oneofs().ByName(n); d != nil {
			return d
		}
		if d := md.Messages().ByName(n); d != nil {
			return d
		}
		if d := md.Enums().ByName(n); d != nil {
			return d
		}
		if d := md.Extensions().ByName(n); d != nil {
			return d
		}
		// enum values are defined in the scope that encloses the enum, so
		// we have to look in all enums to find enum values at this level
		enums := md.Enums()
		for i, length := 0, enums.Len(); i < length; i++ {
			enum := enums.Get(i)
			if d := enum.Values().ByName(n); d != nil {
				return d
			}
		}
		// not in this file
		return nil
	}

	// >1 name means it's inside a nested message
	first := protoreflect.Name(symbolParts[0])
	rest := symbolParts[1:]
	if nested := md.Messages().ByName(first); nested != nil {
		return findSymbolInMessage(rest, nested)
	}

	// no other option; can't be in this message
	return nil
}

// ResolverFromPool implements the full Resolver interface on top of the
// given DescriptorPool. This can be used to upgrade a *[protoregistry.Files]
// to the Resolver interface. The AsTypeResolver method uses TypesFromResolver,
// so it returns dynamic types.
//
// See also ResolverFromPools.
func ResolverFromPool(pool DescriptorPool) Resolver {
	return &resolverFromPool{DescriptorPool: pool}
}

// ResolverFromPools (plural) is just like ResolverFromPool (singular) except it
// also accepts a TypePool that is used to implement the AsTypeResolver method.
// So instead of always returning dynamic types based on the given DescriptorPool,
// it uses the given TypePool.
func ResolverFromPools(descPool DescriptorPool, typePool TypePool) Resolver {
	return &resolverWithTypes{Resolver: ResolverFromPool(descPool), types: typePool}
}

type resolverFromPool struct {
	DescriptorPool
}

func (r *resolverFromPool) FindMessageByName(name protoreflect.FullName) (protoreflect.MessageDescriptor, error) {
	d, err := r.DescriptorPool.FindDescriptorByName(name)
	if err != nil {
		return nil, err
	}
	msg, ok := d.(protoreflect.MessageDescriptor)
	if !ok {
		return nil, fmt.Errorf("%s is %s, not a message", name, descKindWithArticle(d))
	}
	return msg, nil
}

func (r *resolverFromPool) FindFieldByName(name protoreflect.FullName) (protoreflect.FieldDescriptor, error) {
	d, err := r.DescriptorPool.FindDescriptorByName(name)
	if err != nil {
		return nil, err
	}
	field, ok := d.(protoreflect.FieldDescriptor)
	if !ok {
		return nil, fmt.Errorf("%s is %s, not a field", name, descKindWithArticle(d))
	}
	return field, nil
}

func (r *resolverFromPool) FindExtensionByName(name protoreflect.FullName) (protoreflect.ExtensionDescriptor, error) {
	field, err := r.FindFieldByName(name)
	if err != nil {
		return nil, err
	}
	if !field.IsExtension() {
		return nil, fmt.Errorf("%s is a normal field, not an extension", name)
	}
	return field, nil
}

func (r *resolverFromPool) FindOneofByName(name protoreflect.FullName) (protoreflect.OneofDescriptor, error) {
	d, err := r.DescriptorPool.FindDescriptorByName(name)
	if err != nil {
		return nil, err
	}
	oneof, ok := d.(protoreflect.OneofDescriptor)
	if !ok {
		return nil, fmt.Errorf("%s is %s, not a oneof", name, descKindWithArticle(d))
	}
	return oneof, nil
}

func (r *resolverFromPool) FindEnumByName(name protoreflect.FullName) (protoreflect.EnumDescriptor, error) {
	d, err := r.DescriptorPool.FindDescriptorByName(name)
	if err != nil {
		return nil, err
	}
	enum, ok := d.(protoreflect.EnumDescriptor)
	if !ok {
		return nil, fmt.Errorf("%s is %s, not an enum", name, descKindWithArticle(d))
	}
	return enum, nil
}

func (r *resolverFromPool) FindEnumValueByName(name protoreflect.FullName) (protoreflect.EnumValueDescriptor, error) {
	d, err := r.DescriptorPool.FindDescriptorByName(name)
	if err != nil {
		return nil, err
	}
	enumVal, ok := d.(protoreflect.EnumValueDescriptor)
	if !ok {
		return nil, fmt.Errorf("%s is %s, not an enum value", name, descKindWithArticle(d))
	}
	return enumVal, nil
}

func (r *resolverFromPool) FindServiceByName(name protoreflect.FullName) (protoreflect.ServiceDescriptor, error) {
	d, err := r.DescriptorPool.FindDescriptorByName(name)
	if err != nil {
		return nil, err
	}
	svc, ok := d.(protoreflect.ServiceDescriptor)
	if !ok {
		return nil, fmt.Errorf("%s is %s, not a service", name, descKindWithArticle(d))
	}
	return svc, nil
}

func (r *resolverFromPool) FindMethodByName(name protoreflect.FullName) (protoreflect.MethodDescriptor, error) {
	d, err := r.DescriptorPool.FindDescriptorByName(name)
	if err != nil {
		return nil, err
	}
	mtd, ok := d.(protoreflect.MethodDescriptor)
	if !ok {
		return nil, fmt.Errorf("%s is %s, not a method", name, descKindWithArticle(d))
	}
	return mtd, nil
}

func (r *resolverFromPool) FindExtensionByNumber(message protoreflect.FullName, field protoreflect.FieldNumber) (protoreflect.ExtensionDescriptor, error) {
	extd := FindExtensionByNumber(r.DescriptorPool, message, field)
	if extd == nil {
		return nil, ErrNotFound
	}
	return extd, nil
}

func (r *resolverFromPool) RangeExtensionsByMessage(message protoreflect.FullName, fn func(protoreflect.ExtensionDescriptor) bool) {
	RangeExtensionsByMessage(r.DescriptorPool, message, fn)
}

func (r *resolverFromPool) FindMessageByURL(url string) (protoreflect.MessageDescriptor, error) {
	return r.FindMessageByName(TypeNameFromURL(url))
}

func (r *resolverFromPool) AsTypeResolver() TypeResolver {
	return TypesFromResolver(r)
}

type resolverWithTypes struct {
	Resolver
	types TypePool
}

func (r *resolverWithTypes) AsTypeResolver() TypeResolver {
	return r.types
}

func (r *resolverWithTypes) AsTypePool() TypePool {
	return r.types
}
